// Inspired by the idea that you can discover all the values as you go from https://rosettacode.org/wiki/Zebra_puzzle#EchoLisp
// Also then just apply the rules/facts from the top down

operator (candidate overlap clue)
  ({| $candidate... -> {field: $}|} matching {| $clue... -> {field: $}|}) !
end overlap

test 'overlap'
  assert ({nationality: 'English', colour: 'red'} overlap {nationality: 'English', colour: 'red'}) -> $::count <=2> 'identity'
  assert ({nationality: 'English'} overlap {nationality: 'English', colour: 'red'}) -> $::count <=1> 'partial'
  assert ({} overlap {nationality: 'English', colour: 'red'}) -> $::count <=0> 'none'
  assert ({nationality: 'German'} overlap {nationality: 'English', colour: 'red'}) -> $::count <=0> 'contradict'
end 'overlap'

templates has&{house:}
  def street: $;
  $ -> #
  when <[<?(($ overlap $house) -> $::count <=2>)>]> do $ !
  when <[<?(($ overlap $house) -> $::count <=1>)>=2]> do !VOID
  when <[<?(($ overlap $house) -> $::count <=1>)?(({|$|} notMatching {|$house|}) -> $::count <=1>)>]> do !VOID
  when <[<?(($ overlap $house) -> $::count <=1>)>]> do
    $ -> \[i](when <?(($ overlap $house) -> $::count <=1>)> do [$street(first..~$i)..., {$, $house}, $street($i~..last)...] ! \)... !
  otherwise $ -> \[i](({|$|} matching {|$house|})... -> [$street(first..~$i)..., {$, $house}, $street($i~..last)...] ! \)... !
end has

templates follows&{left:, right:}
  data
    is-left <?(($ overlap $left) -> $::count <=1>)>,
    is-right <?(($ overlap $right) -> $::count <=1>)>,
    can-be-right <?(({|$|} matching {|$right|}) -> $::count <=1>)>,
    can-be-left <?(({|$|} matching {|$left|}) -> $::count <=1>)>
  local
  def street: $;
  $ -> #
  when <[(<is-left>:<is-right>)]> do $ !
  when <[<is-left>,<is-right>]> do !VOID
  when <[(<is-left>:<can-be-right>)]> do
    $ -> \[i](($ overlap $left)... -> [$street(first..$i)..., {$street($i+1), $right}, $street($i+1~..last)...] ! \)... !
  when <[(<can-be-left>:<is-right>)]> do
    $ -> \[i](($ overlap $right)... -> [$street(first..~$i-1)..., {$street($i-1), $left}, $street($i..last)...] ! \)... !
  when <[<is-left|is-right>]> do !VOID
  otherwise
    $street::first..~$street::last -> \(
      def i: $;
      ({|$street($i)|} matching {|$left|})...
      -> ({|$street($i+1)|} matching {|$right|})...
      -> [$street(first..~$i)..., {$street($i), $left}, {$street($i+1), $right}, $street($i+1~..last)...] !
    \) !
end follows

templates next-to&{a:, b:}
  $ -> follows&{left: $a, right: $b} !
  $ -> follows&{left: $b, right: $a} !
end next-to

// There are five houses.
[1..5 -> {number: $}]
// The English man lives in the red house.
-> has&{house: {nationality: 'English', colour: 'red'}}
// The Swede has a dog.
-> has&{house: {nationality: 'Swede', pet: 'dog'}}
// The Dane drinks tea.
-> has&{house: {nationality: 'Dane', drink: 'tea'}}
// The green house is immediately to the left of the white house.
-> follows&{left: {colour: 'green'}, right: {colour: 'white'}}
// They drink coffee in the green house.
-> has&{house: {colour: 'green', drink: 'coffee'}}
// The man who smokes Pall Mall has a bird.
-> has&{house: {smoke: 'Pall Mall', pet: 'bird'}}
// In the yellow house they smoke Dunhill.
-> has&{house: {colour: 'yellow', smoke: 'Dunhill'}}
// In the middle house they drink milk.
-> has&{house: {number: 3, drink: 'milk'}}
// The Norwegian lives in the first house.
-> has&{house: {number: 1, nationality: 'Norwegian'}}
// The Blend-smoker lives in the house next to the house with a cat.
-> next-to&{a: {smoke: 'Blend'}, b: {pet: 'cat'}}
// In a house next to the house with a horse, they smoke Dunhill.
-> next-to&{a: {pet: 'horse'}, b: {smoke: 'Dunhill'}}
// The man who smokes Blue Master drinks beer.
-> has&{house: {smoke: 'Blue Master', drink: 'beer'}}
// The German smokes Prince.
-> has&{house: {nationality: 'German', smoke: 'Prince'}}
// The Norwegian lives next to the blue house.
-> next-to&{a: {nationality: 'Norwegian'}, b: {colour: 'blue'}}
// They drink water in a house next to the house where they smoke Blend.
-> next-to&{a: {drink: 'water'}, b: {smoke: 'Blend'}}
-> \(
      $... -> #
      $-> \[i]('$i;: $;' !\)... -> '$;$#10;' -> !OUT::write
             '$#10;' -> !OUT::write

      when <{pet: VOID}> do 'The $.nationality; owns the zebra.$#10;' -> !OUT::write
   \)
-> !VOID

