Things to add/improve
- modules/packages, imports/exports. Interfaces vs implementations? Module interfaces (free templates) vs Processor protocols?
  I like that code should be able to specify what it needs and let it be fulfilled by duck typing.
- testing: should be integrated in the source file
- Contracts and type specifications: Based on matchers. Maybe "templates connect requires <[<point>*]> produces <line>*"
  How about matchers for processor protocols? Specify minimum requirements, extra stuff allowed.
- More matchers. Additive types. Do we need restrictive matchers, specifying e.g. "and nothing else"? More specific list content matchers?
- Concurrency: The basic idea is that state variable changes will be transactional/atomic for each processor template or template chain stage.
  Mechanism will likely be "CAS or retry". How about processors holding processors, giving a "distributed" transaction?
- Rational numbers, exact math?
- Scientific numbers, specify digits of accuracy. Units required? Syntax when going from exact number division?
- Standard library. Should definitely include relvars as DB-interface (see The Third Manifesto).
- Performance. Definitely need better data structures for lists and structures.
- Error handling. Error path/exception path? VOID path? Need examples to play with.
- Want prepend to array/structure. Syntax? ..< and ..> instead of ..| maybe or >> and << ?

Errors easy to make
- Mixed up ..$bound and $bound.., hard to see error
- Given source abc, hard to see call to $abc when intended $@abc
- Easy to forget to use the name of the outer template in a simple filter \(<=$@.foo> $ !\)

Illogical?
- Should it be \[i;j](...) in array templates since dimensions vary by ';'?
- Using negative numbers to index from the end of the array is a bit hard to read. Also disallows the "trick" of $a($-2..$-2)
  for optional fetches below zero (it works after end).
- Array references should maybe always have [] around multi-value references? Particularly array-valued dereferences and ranges.
- We should be able to use inline templates as sources and sinks (?) array generators (array template source)?
- Should we be able to specify defined templates to be array templates?

Bugs
- delete of several array elements doesn't work as expected

Too much syntax?
- quick filter by \<match> to mean \(<match> $!\).
- filter array dereference, $a(<match>) to select all elements that match, like $a -> \[_](<match> $!\)
  The downside of this one is that it doesn't extend easily? Or textually it actually does!
- allow array templates to have persistent state. Syntax for initializing? Easy enough to wrap the array templates?
- More sugar for state-changes, e.g. ..+ or may ++ to add to the state variable?
- Array templates where you select a slice (or maybe all) of a dimension

Other thoughts
- Use more words instead of symbols?
- How much meta-programming do we want to let loose? Should everything be assignable as data? In that case, what about serialization?
  Currently processors are a little in-between: if we can pass processor instances, why not templates? Or conversely?
- Maybe some kind of reflective access? E.g. field access like myStruct."$fieldName;"? But do we need it?
  I really want to avoid things that complicate if there is a reasonable way to do something similar.
- Different kinds of hand-over between transforms? E.g. '=>' for proceed in parallel.
- Do we need some kind of exit statement to abandon a stream?
- Vector arithmetic?
