Things to add/improve
- Backtracking and left-recursion in composers
- modules/packages, imports/exports. Interfaces vs implementations? Module interfaces (free templates) vs Processor protocols?
  I like that code should be able to specify what it needs and let it be fulfilled by duck typing.
- Standard library.
  - Should definitely include relvars as DB-interface (see The Third Manifesto). API vs impl?
  - networking
  - files. File systems? module loading of API vs implementation? Handled by duck-typing?
- Contracts and type specifications: Based on matchers. Maybe "templates connect requires <[<point>*]> produces <line>*"
  How about matchers for processor protocols? Specify minimum requirements, extra stuff allowed.
- More matchers. Additive types. Do we need restrictive matchers, specifying e.g. "and nothing else"? More specific list content matchers?
- Concurrency: The basic idea is that state variable changes will be transactional/atomic for each processor template or template chain stage.
  Mechanism will likely be "CAS or retry". How about processors holding processors, giving a "distributed" transaction?
- Rational numbers, exact math?
- Scientific numbers, specify digits of accuracy. Units required? Syntax when going from exact number division?
- Performance. Definitely need better data structures for lists and structures.
- Error handling. Error path/exception path? VOID path? Need examples to play with.
- Want prepend to array/structure. Syntax? ..< and ..> instead of ..| maybe or >> and << ? Does a stream get prepended
  in reverse or as a chunk? 1..3 -> |..@: $;

Errors easy to make
- Mixed up ..$bound and $bound.., hard to see error
- Given source abc, hard to see call to $abc when intended $@abc
- Easy to forget to use the name of the outer template in a simple filter \(<=$@.foo> $ !\)

Illogical?
- We should be able to use inline templates as sources and sinks (?) array generators (array template source)?
- Should we be able to specify defined templates to be array templates?

Bugs
- delete of several array elements doesn't work as expected

Too much syntax?
- quick filter by \<match> to mean \(<match> $!\).
- filter array dereference, $a(<match>) to select all elements that match, like $a -> \[_](<match> $!\)
  The downside of this one is that it doesn't extend easily? Or textually it actually does!
- allow array templates to have persistent state. Syntax for initializing? Easy enough to wrap the array templates?
- More sugar for state-changes, e.g. ..+ or may ++ to add to the state variable?
- Array templates where you select a slice (or maybe all) of a dimension

Other thoughts
- Use more words instead of symbols? YES, easier to scan and search. Even redundant words (to some limit).
- How much meta-programming do we want to let loose? Should everything be assignable as data? In that case, what about serialization?
  Currently processors are a little in-between: if we can pass processor instances, why not templates? Or conversely?
- Maybe some kind of reflective access? E.g. field access like myStruct."$fieldName;"? But do we need it?
  I really want to avoid things that complicate if there is a reasonable way to do something similar.
- Different kinds of hand-over between transforms? E.g. '=>' for proceed in parallel.
- Do we need some kind of exit statement to abandon a stream? e.g. "findFirst"/"findAny" Or do you have to code it as iterated matching?
- Vector arithmetic?
- Binary operators?
