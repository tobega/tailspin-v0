The main program/process should have full control of the dependencies of its dependencies.
You should have full freedom to replace any symbol in a module. That replacement will then also be used internally in the module.

An external dependency is given by the symbol module: followed by the path from any directory in the configured module-path
All external dependencies have to be explicitly configured with their external dependencies, as well as their core dependencies.

Core dependencies are specified by core:name. Any core symbol can also be overridden.
The core:system dependency does not normally have to be declared on the top level.

An internal dependency is given by a path that corresponds to the path from the current module's root (default same directory as the file),
which can be determined by backing up the path given in the module declaration in the file.
Internal dependencies by default have same privileges as the dependent file inherited.
A calling program should still be able to replace internal dependencies of its dependencies, but that is optional.

Syntax is tentative:
- Say the program depends on foo depends on bar and baz where baz uses system utilities (e.g. OUT)

use 'module:foo' with
  'module:bar' stand-alone
  'module:baz' with
    core-system/ inherited
  provided
provided

If bar has any dependencies, these are not supplied so we cannot use anything that uses them.

- Same as above but we don't trust baz, so we provide our own system utils in another module without access to the real ones

use 'module:foo' with
  'module:bar' stand-alone
  'module:baz' with
    core-system/ from 'fake/system.tt' stand-alone
  provided
provided

- Let's say that foo also needs system, we give it the fake, then anything foo uses (e.g. baz) can never use anything foo
  doesn't have, so even on inherit it will get the fake

use 'module:foo' with
  core-system/ from 'fake/system' stand-alone
  'module:bar' stand-alone
  'module:baz' with
    core-system/ inherited // now equivalent to: from 'fake/system'
  provided
provided

- free-form example of various combinations

use modified 'module:foo'
  with
    bar/ inherited
    defined baz/
      templates g !VOID end g
    end baz/
    modified qux/ from 'module:qux2'
      with ... provided
      ...
    end qux/
    fum/ from 'module:blabla'
  provided

  templates beeble // defined as if on top level, except when refs to enclosed
    'beebled $;' -> !OUT::write
    $ -> enclosed beeble !
  end beeble
end foo/