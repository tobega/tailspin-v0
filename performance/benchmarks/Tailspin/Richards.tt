include 'harness'

def NO_TASK: {};
def NO_WORK: {};
def IDLER: 1;
def WORKER: 2;
def HANDLER_A: 3;
def HANDLER_B: 4;
def DEVICE_A: 5;
def DEVICE_B: 6;
def NUM_TYPES: 6;

def DEVICE_PACKET_KIND: 0;
def WORK_PACKET_KIND: 1;

def DATA_SIZE: 4;

def TRACING: 0;

processor Stats
  @: {
    queuePacketCount: 0,
    holdCount: 0
  };
  sink incrementQueuePacketCount
    @Stats.queuePacketCount: $ + $@Stats.queuePacketCount;
  end incrementQueuePacketCount
  sink incrementHoldCount
    @Stats.holdCount: $ + $@Stats.holdCount;
  end incrementHoldCount
  source get
    $@Stats!
  end get
end Stats

processor Scheduler&{stats:}
  @: {
    layout: 0,
    taskTable: [1..$NUM_TYPES -> $NO_TASK],
    taskList: $NO_TASK,
    currentTask: $NO_TASK,
    currentTaskIdentity: 0
  };

  sink createTask&{task:}
    $ -> TaskControlBlock&{link: $@Scheduler.taskList, task: $task}
      -> \(
        @Scheduler.taskList: $;
        @Scheduler.taskTable($::getIdentity): $;
      \) -> !VOID
  end createTask

  sink trace
    @Scheduler.layout: $@Scheduler.layout - 1
      -> \(<..0> '$#10;' -> !OUT::write 50! <> $! \);
    $ -> !OUT::write
  end trace

  templates findTask
    $@Scheduler.taskTable($)!
  end findTask

  templates queuePacket
    def packet: $;
    $packet::getIdentity -> findTask -> #
    when <=$NO_TASK> do $NO_TASK !
    otherwise
      def t: $;
      1 -> !stats::incrementQueuePacketCount
      $@Scheduler.currentTaskIdentity -> !packet::setIdentity
      $packet -> !t::addInput
      $t!
  end queuePacket

  source holdSelf
    1 -> !stats::incrementHoldCount
    1 -> !@Scheduler.currentTask::setTaskHolding
    $@Scheduler.currentTask!
  end holdSelf

  templates release
    $ -> findTask -> #
    when <=$NO_TASK> do $NO_TASK !
    otherwise
      def t: $;
      0 -> !t::setTaskHolding
      $t !
  end release

  source markWaiting
    1 -> !@Scheduler.currentTask::setTaskWaiting
    $@Scheduler.currentTask !
  end markWaiting

  sink createDevice
    def task: $DeviceTask&{queuePacket: queuePacket, holdSelf: holdSelf, markWaiting: markWaiting};
    $ -> !createTask&{task: $task}
  end createDevice

  sink createHandler
    def task: $HandlerTask&{queuePacket: queuePacket, markWaiting: markWaiting};
    $ -> !createTask&{task: $task}
  end createHandler

  sink createIdler
    def task: $IdleTask&{release: release, holdSelf: holdSelf};
    $ -> !createTask&{task: $task}
  end createIdler

  sink createWorker
    def task: $WorkerTask&{queuePacket: queuePacket, markWaiting: markWaiting};
    $ -> !createTask&{task: $task}
  end createWorker

  source schedule
    @Scheduler.currentTask: $@Scheduler.taskList;
    $@Scheduler.currentTask -> #
    when <=$NO_TASK> !VOID
    when <?($::isTaskHoldingOrWaiting <=1>)> do
      @Scheduler.currentTask: $::getLink;
      $@Scheduler.currentTask -> #
    otherwise
      @Scheduler.currentTaskIdentity: $::getIdentity;
      $::getIdentity -> \(<?($TRACING <=1>)> $!\) -> !trace
      @Scheduler.currentTask: $::runTask -> \(
        when <?($::getPriority <$@Scheduler.currentTask::getPriority~..>)> do $!
        otherwise $@Scheduler.currentTask !
      \);
//      @Scheduler.currentTask: 1 -> \(@: {priority: -1, taskIdentity: 0};
//        $@Scheduler.taskTable... -> #
//        $@.taskIdentity -> \(<=0> $NO_TASK! <> $@Scheduler.taskTable($) ! \)!
//        when <?($::isTaskHoldingOrWaiting <=1>)> do !VOID
//        when <?($::getPriority <$@.priority~..>)> do @: { priority: $::getPriority, taskIdentity: $::getIdentity};
//      \);
      $@Scheduler.currentTask -> #
  end schedule

  source start
    [$IDLER, 0, $NO_WORK, $taskStateRunning] -> !createIdler

    [1..2 -> {identity: $WORKER, kind: $WORK_PACKET_KIND} -> Packet]
    -> [$WORKER, 1000, $, $taskStateWaitingWithPacket] -> !createWorker

    [1..3 -> {identity: $DEVICE_A, kind: $DEVICE_PACKET_KIND} -> Packet]
    -> [$HANDLER_A, 2000, $, $taskStateWaitingWithPacket] -> !createHandler

    [1..3 -> {identity: $DEVICE_B, kind: $DEVICE_PACKET_KIND} -> Packet]
    -> [$HANDLER_B, 3000, $, $taskStateWaitingWithPacket] -> !createHandler

    [$DEVICE_A, 4000, [], $taskStateWaiting] -> !createDevice
    [$DEVICE_B, 5000, [], $taskStateWaiting] -> !createDevice

    $schedule -> !VOID
  end start
end Scheduler

processor DeviceTask&{queuePacket:, holdSelf:, markWaiting:}
  @:$NO_WORK;
  templates function
    when <=$NO_WORK> do
      $@DeviceTask -> \(
        <=$NO_WORK> $markWaiting !
        otherwise
          @DeviceTask: $NO_WORK;
          $ -> queuePacket !
      \) !
    otherwise
      @DeviceTask: $;
//      $ -> \(<?($TRACING <=1>)> $::getDatum !\) -> !trace
      $holdSelf !
  end function
end DeviceTask

processor HandlerTask&{queuePacket:, markWaiting:}
  @: { workIn: [], deviceIn: []};
  templates function
    $ -> \(<~=$NO_WORK> $! \)
      -> \(
        when <?($::getKind <=$WORK_PACKET_KIND>)> do
          ..|@HandlerTask.workIn: $;
        otherwise
          ..|@HandlerTask.deviceIn: $;
      \) -> !VOID
    $@HandlerTask.workIn::length -> \(
      when <=0> do $markWaiting!
      otherwise
        $@HandlerTask.workIn(1)::getDatum -> \(
          when <$DATA_SIZE..> do
            ^@HandlerTask.workIn(1) -> queuePacket !
          otherwise
            def count: $;
            def workPacket: $@HandlerTask.workIn(1);
            $@HandlerTask.deviceIn::length -> \(
              when <=0> do $markWaiting!
              otherwise
                def devicePacket: ^@HandlerTask.deviceIn(1);
                $workPacket::getData&{i: $count} -> !devicePacket::setDatum
                $count + 1 -> !workPacket::setDatum
                $devicePacket -> queuePacket !
            \) !
        \) !
    \) !
  end function
end HandlerTask

processor IdleTask&{release:, holdSelf:}
  @: { control: [x01x] -> $(last-3..last), count: 10000};
  source decrementCount
    @IdleTask.count: $@IdleTask.count - 1;
    $@IdleTask.count !
  end decrementCount
  templates function
    $decrementCount -> \(
      when <=0> do $holdSelf!
      otherwise
        ($@IdleTask.control and [x01x]) -> $(last) -> \(
          when <=[x00x]> do
            @IdleTask.control: $@IdleTask.control -> $::shift&{left:-1, fill: $(0)};
            $DEVICE_A -> release !
          otherwise
            @IdleTask.control: $@IdleTask.control
              -> ($::shift&{left:-1, fill: $(0)} xor (53256 -> $::asBytes));
            $DEVICE_B -> release !
        \) !
    \) !
  end function
end IdleTask

processor WorkerTask&{queuePacket:, markWaiting:}
  @: {destination: $HANDLER_A, count: 0};
  templates function
    when <=$NO_WORK> do $markWaiting!
    otherwise
      def work: $;
      @WorkerTask.destination: $@WorkerTask.destination -> \(<=$HANDLER_A> $HANDLER_B! <> $HANDLER_A!\);
      $@WorkerTask.destination -> !work::setIdentity
      0 -> !work::setDatum
      0..~$DATA_SIZE -> \(
        def i: $;
        @WorkerTask.count: $@WorkerTask.count + 1 -> \(<..26> $! <> 1!\);
        65 + $@WorkerTask.count - 1 -> !work::setData&{i: $i}
      \) -> !VOID
      $work -> queuePacket !
  end function
end WorkerTask

processor Packet
  @: { $..., datum: 0, data: [1..$DATA_SIZE -> 0] };
  source getKind
    $@Packet.kind!
  end getKind
  source getDatum
    $@Packet.datum !
  end getDatum
  sink setDatum
    @Packet.datum: $;
  end setDatum
  source getData&{i:}
    $@Packet.data($i+1)!
  end getData
  sink setData&{i:}
    @Packet.data($i+1): $;
  end setData
  source getIdentity
    $@Packet.identity!
  end getIdentity
  sink setIdentity
    @Packet.identity: $;
  end setIdentity
end Packet

processor TaskControlBlock&{link:, task:}
  def identity: $(1);
  def priority: $(2);
  @: {input: $(3), $(4)...};

  sink addInput
    $@TaskControlBlock.input::length -> \(
      when <=0> do @TaskControlBlock.packetPending: 1;
    \) -> !VOID
    ..|@TaskControlBlock.input: $;
  end addInput

  source getLink
    $link!
  end getLink

  source getPriority
    $priority!
  end getPriority

  source getIdentity
    $identity!
  end getIdentity

  sink setTaskHolding
    @TaskControlBlock.taskHolding: $;
  end setTaskHolding

  sink setTaskWaiting
    @TaskControlBlock.taskWaiting: $;
  end setTaskWaiting

  source isTaskHoldingOrWaiting
    $@TaskControlBlock.taskHolding -> #
    <=1> 1 !
    <?($@TaskControlBlock.packetPending <=0>)?($@TaskControlBlock.taskWaiting <=1>)> 1!
    <> 0!
  end isTaskHoldingOrWaiting

  source isWaitingWithPacket
    $@TaskControlBlock.taskHolding -> #
    <=1> 0 !
    <?($@TaskControlBlock.packetPending <=1>)?($@TaskControlBlock.taskWaiting <=1>)> 1!
    <> 0!
  end isWaitingWithPacket

  source runTask
    $isWaitingWithPacket -> \(
      when <=1> do
        ^@TaskControlBlock.input(1) !
        $@TaskControlBlock.input::length -> \(
          <=0> ..|@TaskControlBlock: $taskStateRunning;
          <>  ..|@TaskControlBlock: $taskStatePacketPending;
        \) -> !VOID
      otherwise $NO_WORK !
    \) -> task::function !
  end runTask
end TaskControlBlock

source taskStatePacketPending
  { packetPending: 1, taskHolding: 0, taskWaiting: 0 } !
end taskStatePacketPending

source taskStateRunning
  { packetPending: 0, taskHolding: 0, taskWaiting: 0 } !
end taskStateRunning

source taskStateWaiting
  { packetPending: 0, taskHolding: 0, taskWaiting: 1 } !
end taskStateWaiting

source taskStateWaitingWithPacket
  { packetPending: 1, taskHolding: 0, taskWaiting: 1 } !
end taskStateWaitingWithPacket

templates run
  def stats: $Stats;
  $Scheduler&{stats: $stats} -> $::start -> !VOID
  $stats::get -> #
  <{queuePacketCount: <=23246>, holdCount: <=9297>}>
    1 !
  otherwise
    0 !
end run

1 -> harness/run&{name: 'Richards', benchmark:run} -> !VOID
